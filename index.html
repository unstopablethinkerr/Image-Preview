<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Surface Detection Debug</title>
  <style>
    body, html { margin:0; padding:0; overflow:hidden; background:black; }
    #video, #overlay {
      position:absolute; top:0; left:0; width:100%; height:100%;
      object-fit:cover;
    }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline></video>
  <canvas id="overlay"></canvas>

  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script>
    const video = document.getElementById("video");
    const overlay = document.getElementById("overlay");
    const ctx = overlay.getContext("2d");

    // Start camera
    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
      .then(stream => {
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          overlay.width = video.videoWidth;
          overlay.height = video.videoHeight;
        };
      });

    // Run after OpenCV loads
    function onOpenCvReady() {
      cv['onRuntimeInitialized']=()=>{
        console.log("âœ… OpenCV ready");

        const cap = new cv.VideoCapture(video);
        const src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
        const gray = new cv.Mat();
        const edges = new cv.Mat();
        const contours = new cv.MatVector();
        const hierarchy = new cv.Mat();

        function processFrame() {
          if (video.readyState === video.HAVE_ENOUGH_DATA) {
            cap.read(src);
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            cv.Canny(gray, edges, 75, 200);

            ctx.drawImage(video, 0, 0, overlay.width, overlay.height);

            // Test: draw edges as red overlay
            let imgData = new ImageData(new Uint8ClampedArray(edges.data), edges.cols, edges.rows);
            let tmpCanvas = document.createElement("canvas");
            tmpCanvas.width = edges.cols;
            tmpCanvas.height = edges.rows;
            tmpCanvas.getContext("2d").putImageData(imgData, 0, 0);
            ctx.globalAlpha = 0.5;
            ctx.drawImage(tmpCanvas, 0, 0, overlay.width, overlay.height);
            ctx.globalAlpha = 1.0;

            // Contours (optional)
            cv.findContours(edges, contours, hierarchy, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE);
            for (let i = 0; i < contours.size(); i++) {
              const cnt = contours.get(i);
              const peri = cv.arcLength(cnt, true);
              const approx = new cv.Mat();
              cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
              if (approx.rows === 4) {
                ctx.strokeStyle = "lime";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(approx.intAt(0,0), approx.intAt(0,1));
                for (let j = 1; j < 4; j++) {
                  ctx.lineTo(approx.intAt(j,0), approx.intAt(j,1));
                }
                ctx.closePath();
                ctx.stroke();
              }
              approx.delete();
            }
          }
          requestAnimationFrame(processFrame);
        }
        requestAnimationFrame(processFrame);
      }
    }
    onOpenCvReady();
  </script>
</body>
</html>
